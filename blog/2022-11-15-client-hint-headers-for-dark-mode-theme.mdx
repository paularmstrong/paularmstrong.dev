---
draft: true
title: Using client hints to prevent FARTs with website auto dark mode themes
pubDate: 11/15/2022, 12:00:00 PM GMT-0700
description: I originally wanted to avoid using any sort of server-side code for my site, getting around the FART completely is not currently possible when you have a statically generated site. In this post, I'll walk through how I got rid of the flash of inaccurate color themes for Tailwindcss dark mode (with auto media query support!), building off of some others' examples using Netlify Edge Functions.
toc: true
---

import Aside from '~/components/Aside.astro';

Flash of inAccurate coloR Themes[^1], or FART, as [coined by Chris Coyier](https://css-tricks.com/flash-of-inaccurate-color-theme-fart/) is the _fancy_ term for the effect when your device is set to prefer a "dark mode" of all UIs and you see a website flash itself in a light theme and then quickly flip to its dark variant. It's minor, yes, but also super annoying to anyone with a slightly slower connection, as the time at which the theme will switch to dark is dependent on the speed that the JavaScript can download and execute.

I originally wanted to avoid using any sort of server-side code for my site, getting around the FART completely is not currently possible when you have a statically generated site. In this post, I'll walk through how I got rid of the flash of inaccurate color themes for Tailwindcss dark mode (with auto media query support!), building off of some others' examples using Netlify Edge Functions.

This is similar to [a post by Jason Lengstorf](https://www.learnwithjason.dev/blog/css-color-theme-switcher-no-flash), but takes it a big step forward.

I originally wanted to get away with never using cookies for this site, but unfortunately, that’s the only way to have stored information for browsers without using a database to manage sessions.

## Theme switcher component

I’m going to mostly skip over the [theme switch toggle button code](https://github.com/paularmstrong/paularmstrong.dev/blob/e29bd3d602bcd625f9e29360b422c7e1dc0cf86e/src/components/ThemeSwitcher.tsx), as mine is in Solid-js and may look a little funky if you’re used to React.

Here are the important bits of the theme switcher, in React:

To save our theme and whether or not auto-selection is preferred, we can use a basic `fetch` call with `URLSearchParams`. Nothing too special is necessary here:

```tsx
function saveTheme(theme: Theme, auto: boolean) {
	const params = new URLSearchParams({ theme, auto: auto ? 'true' : 'false' });
	fetch(`/api/theme/?${params.toString()}`);
}
```

Then, in our `<ThemeSwitcher />`, we need to create an effect that runs any time our `theme` or `auto` modes have changed and call our API.

As I'm using Tailwindcss, the switch between `dark` and `light` mode only requires that I add or remove the className `dark` on a root element (I’m using `<body />`). I also opted to track whether the theme should be in `auto` mode via a data attribute, `data-auto-theme`.

```tsx title="ThemeSwitcher.tsx (partial)"
export function ThemeSwitcher() {
	const [theme, setTheme] = React.useState(document.body.classList.contains('dark') ? 'dark' : 'light');
	const [auto, setAuto] = React.useState(document.body.dataset.autoTheme === 'true');

	React.useEffect(() => {
		document.body.dataset.autoTheme = auto ? 'true' : 'false';

		if (theme === 'dark') {
			document.body.classList.add('dark');
		} else {
			document.body.classList.remove('dark');
		}

		save(theme, auto);
	}, [theme, auto]);

	// ...
	// there’s more needed here, this is just for demonstration purposes
	// ...
}
```

All in all, this should result in two things:

1. The theme is tracked on the body element, like `<body class="dark" data-auto-theme="true">`
2. Our API (up next) is called every time the user preference changes.

### Prefers color scheme media query

```tsx title="ThemeSwitcher.tsx (partial)"
React.useEffect(() => {
	if (!auto) {
		// do nothing if not in auto mode
		return;
	}

	// on initial change to auto-mode, set the theme based on the current
	// media query preference
	if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
		setTheme('dark');
	} else {
		setTheme('light');
	}

	// Add an event listener any time the device requests a change to the color scheme
	function listener(event: MediaQueryListEvent) {
		setTheme(event.matches ? 'dark' : 'light');
	}
	window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', listener);

	// on unload, remove the event listener
	return () => {
		window.matchMedia('(prefers-color-scheme: dark)').removeEventListener('change', listener);
	};
}, [auto]);
```

## Edge Function as an API

So, let's write our little cookie-setting API as a Netlify Edge Function.

One particular big caveat: Netlify edge functions use Deno, not Node.js! So when you see an `import` statement that pulls from a URL, just know that this is _not_ a mistake.

First off, let’s set up the plumbing for saving our theme choice cookie:

```ts title="netlify/edge-functions/set-theme.ts"
import type { Context } from 'https://edge.netlify.com/';

const themes = ['light', 'dark'] as const;

export default async (req: Request, context: Context) => {
	const url = new URL(req.url);
	const params = url.searchParams;

	const theme = params.get('theme') as typeof themes[number];
	const auto = params.get('auto') === 'true';

	context.cookies.set({
		name: 'theme',
		value: params.toString(),
		path: '/',
		secure: true,
		httpOnly: true,
		sameSite: 'Strict',
		expires: new Date(Date.now() + 2_592_000_000),
	});

	return new Response(JSON.stringify({ error: false }), {
		status: 200,
		headers: {
			'content-type': 'application/json',
		},
	});
};
```

Lastly, don't forget to add the edge function declaration to the `netlify.toml` configuration:

```toml title="netlify.toml"
[[edge_functions]]
	path = "/api/theme/*"
	function = "set-theme"
```

## Accepting Client Hint headers

Now comes some of the magic for auto-selecting color themes for users in the future. We need to tell browsers that we will accept the [`prefers-color-scheme` client hint](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme).

To do this, in our Netlify `_headers` file, add the following so that all pages respond with the `accept-ch` header:

```text title="_headers"
/*
	accept-ch: sec-ch-prefers-color-scheme
```

<Aside type="danger" title="Client hints*">

It is important to note a really huge asterisk here, that I will likely have written [multiple times](#downsides) once this is all done[^2]: client hints only work in some browsers and require at least one full network round-trip before the browser will start sending them to the server.

</Aside>

## Rewriting static HTML responses

Once again, we’ll use an edge function from Netlify for this. I'll walk through this one a bit to help explain better.

First, let's start with a barebones edge function:

```ts title="netlify/edge-functions/theme.ts"
// Remember: this is Deno, not Node.js!
import type { Context } from 'https://edge.netlify.com/';
import { HTMLRewriter, Element } from 'https://ghuc.cc/worker-tools/html-rewriter/index.ts';

export default async (req: Request, context: Context) => {
	// Get the default response for this URL. This will grab the actual response as if we were not running this function
	const res = await context.next();

	// Check the content type. If we're not serving HTML, running the rest of this function is a waste of compute time and power
	const type = res.headers.get('content-type');
	if (!type?.startsWith('text/html')) {
		return;
	}
};
```

Next, we need to try to read the cookie and fall back on a default value if it's not available. Using nullish-coalescing, we can make this fairly simple, as long as we trust no one in the middle is messing withour cookie value:

```ts
const rawCookie = context.cookies.get(COOKIE_NAME) ?? 'auto=true&theme=light';
const params = new URLSearchParams(rawCookie);
const isAuto = params.get('auto') === 'true';
const theme = params.get('theme') || 'light';
```

But the whole point of the `auto` setting on our theme switcher is that we want to read from the `prefers-color-scheme` client hint. So we'll modify this block just a smidge to read the header and if the cookie states that auto-mode is preferred, we'll use the header value if it's available!

```diff
+ const prefers = req.headers.get('sec-ch-prefers-color-scheme');
	const rawCookie = context.cookies.get(COOKIE_NAME) ?? 'auto=true&theme=light';
	const params = new URLSearchParams(rawCookie);
	const isAuto = params.get('auto') === 'true';
- const theme = params.get('theme') || 'light';
+ const theme = isAuto && prefers ? prefers : params.get('theme') || 'light';
```

Lastly, just like in [the inspiration from “Learn with Jason”](https://www.learnwithjason.dev/blog/css-color-theme-switcher-no-flash#update-the-currently-selected-theme-in-the-dropdown), we'll use the HTMLRewriter and update the `className` and `data-auto-theme` attributes on our `<body>` element. All-together, our function looks like this:

```tsx showLineNumbers title="netlify/edge-functions/theme.ts" {17-25}
import type { Context } from 'https://edge.netlify.com/';
import { HTMLRewriter, Element } from 'https://ghuc.cc/worker-tools/html-rewriter/index.ts';

export default async (req: Request, context: Context) => {
	const res = await context.next();
	const type = res.headers.get('content-type');
	if (!type?.startsWith('text/html')) {
		return;
	}

	const prefers = req.headers.get('sec-ch-prefers-color-scheme');
	const rawCookie = context.cookies.get('theme') ?? 'auto=true&theme=light';
	const params = new URLSearchParams(rawCookie);
	const isAuto = params.get('auto') === 'true';
	const theme = isAuto && prefers ? prefers : params.get('theme') || 'light';

	return new HTMLRewriter()
		.on('body', {
			element(element: Element) {
				const original = element.getAttribute('class') || false;
				element.setAttribute('class', [original, theme].filter(Boolean).join(' '));
				element.setAttribute('data-auto-theme', isAuto ? 'true' : 'false');
			},
		})
		.transform(res);
};
```

Now we actually need to enable the edge function. In our `netlify.toml`, like we did before for the `set-theme` function:

```toml title="netlify.toml"
[[edge_functions]]
  path = "/*"
  function = "theme"
```

Another caveat: even though we're ejecting early from our edge function if the response does not have the `text/html` content type, there is still a limited number of edge function runs on the Netlify free plan. Yes, the limit is a big number, current 3 million, but, let's do our best not to get hit by any surprises.

I've split up my edge function into only running on known HTML page paths. I would have liked to have seen better path matching or a way to do an exclude-list along with a path glob, but alas, that feature does not exist yet.

```toml title="netlify.toml"
[[edge_functions]]
  path = "/"
  function = "theme"

[[edge_functions]]
  path = "/blog/*"
  function = "theme"

[[edge_functions]]
  path = "/about/*"
  function = "theme"

# ...etc... add as needed
```

## Downsides

First and foremost: Client Hints are still considered "experimental" and only available in Chromium-based browsers. For anyone not using one of those, the auto-theme selection won't work and the [theme setting edge function](#edge-functions-as-an-api) will fall back on the last known `theme` value per the cookie.

Secondly, Client Hints are not provided by the browser to the server on _first_ load. While there are ongoing discussions about allows this to happen, there are technical challenges in making browsers first check which hints are being requested in order to send them. All this means that the even if you're using a browser that supports Client Hints, your first page load to the site will always have a FART.

We _could_ work around that by forcing a redirect/reload on first load, but that would require quite a bit of extra work that is frankly not worth the effort.

[^1]: I tried to avoid using this silly acronym in the title, but it is kinda fun. Sorry if you’re too mature for 💨 jokes, because I’m not.
[^2]: Client hints are currently only supported by Chromium-based browsers. This is a huge shame, but hopefully more pressure will be put on other browsers to get traction soon. See the section on [downsides](#downsides) for more information.

<Aside type="info" title="Alternative post titles">

I had some other stupid post titles in mind, but eventually settled on the safe, SEO-friendly one. But thought I'd share some here anyway:

- It’s like Gas-X, but for websites!
- Warn me with a _hint_ before you FART

</Aside>
