---
draft: true
title: Using client hints to prevent FARTs with website auto dark mode themes
pubDate: 11/15/2022, 12:00:00 PM GMT-0700
description: I originally wanted to avoid using any sort of server-side code for my site, getting around the FART completely is not currently possible when you have a statically generated site. In this post, I‚Äôll walk through how I got rid of the flash of inaccurate color themes for Tailwindcss dark mode (with auto media query support!), building off of some others‚Äô examples using Netlify Edge Functions.
toc: true
---

import Aside from '~/components/Aside.astro';

Flash of inAccurate coloR Themes[^acronym], or <acronym title="Flash of inAccurate coloR Themes">FART</acronym>, as [coined by Chris Coyier](https://css-tricks.com/flash-of-inaccurate-color-theme-fart/) is the _fancy_ term for the effect when your device is set to prefer a "dark mode" of all UIs and you see a website flash itself in a light theme and then quickly flip to its dark variant. It‚Äôs minor, yes, but also super annoying to anyone with a slightly slower connection, as the time at which the theme will switch to dark is dependent on the speed that the JavaScript can download and execute.

[^acronym]: I tried to avoid using this silly acronym in the title, but it is kinda fun. Sorry if you‚Äôre too mature for üí® jokes, because I‚Äôm not.

I came across [a post by Jason Lengstorf](https://www.learnwithjason.dev/blog/css-color-theme-switcher-no-flash) about avoiding the <acronym title="Flash of inAccurate coloR Themes">FART</acronym> by using Netlify‚Äôs new [Edge Functions](https://docs.netlify.com/edge-functions/overview/). Lucky me, I‚Äôm using Netlify and a [statically-built site](/blog/2022/11/09/the-case-for-astro/), so I figured this would be a great approach for me.

_**Except there was a big issue.**_

Many theme pickers, including the example I was following, allow picking only ‚Äúlight‚Äù or ‚Äúdark‚Äù as your theme. While it‚Äôs kind to provide a choice, for those who want one versus another, it misses out on providing those that would love to keep their system preference instead.

Tailwindcss, which I‚Äôm using, allows a one-or-the-other approach as well. By default, you can let it use the `prefers-color-scheme` approach. Alternatively, you can change it to `darkMode: 'class'` to control it yourself.

I originally wanted to avoid using any sort of server-side code for my site, getting around the <acronym title="Flash of inAccurate coloR Themes">FART</acronym> completely is not currently possible when you have a statically generated site. In this post, I‚Äôll walk through how I got rid of the flash of inaccurate color themes for Tailwindcss dark mode, building upon [Jason‚Äôs work](https://www.learnwithjason.dev/blog/css-color-theme-switcher-no-flash) to add ‚Äúauto‚Äù theme support using [HTTP client hints](https://developer.mozilla.org/en-US/docs/Web/HTTP/Client_hints) and media queries.

## Theme switcher component

I‚Äôm going to mostly skip over the [theme switch toggle button code](https://github.com/paularmstrong/paularmstrong.dev/blob/e29bd3d602bcd625f9e29360b422c7e1dc0cf86e/src/components/ThemeSwitcher.tsx), as mine is in Solid-js and may look a little funky if you‚Äôre used to React.

Here are the important bits of the theme switcher, in React:

First, as I‚Äôm using Tailwindcss, the switch between `dark` and `light` mode only requires that I add or remove the className `dark` on a root element (I‚Äôm using `<body />`). To ensure Tailwind is set up for this, we need to set `darkMode: 'class'`:

```js title="tailwind.conf.cjs" {3}
module.exports = {
	content: ['src/**/*.{astro,md,mdx,tsx,ts}'],
	darkMode: 'class',
};
```

To save our theme and whether or not auto-selection is preferred, we can use a basic `fetch` call with `URLSearchParams`. Nothing too special is necessary here:

```tsx
function saveTheme(theme: Theme, auto: boolean) {
	const params = new URLSearchParams({ theme, auto: auto ? 'true' : 'false' });
	fetch(`/api/theme/?${params.toString()}`);
}
```

Then, in our `<ThemeSwitcher />`, we need to create an effect that runs any time our `theme` or `auto` modes have changed and call our API. Note that I‚Äôm also tracking the source of truth for ‚Äúauto‚Äù mode with a data attribute attached to the `<body>` element.

Here‚Äôs an example effect in React. If you‚Äôd prefer the full component written for Solid-js, check the [source on Github](https://github.com/paularmstrong/paularmstrong.dev/blob/8683b83f5fcebaa223b658bc1881d2db0be14524/src/components/ThemeSwitcher.tsx).

```tsx title="ThemeSwitcher.tsx"
export function ThemeSwitcher() {
	const [theme, setTheme] = React.useState(document.body.classList.contains('dark') ? 'dark' : 'light');
	const [auto, setAuto] = React.useState(document.body.dataset.autoTheme === 'true');

	React.useEffect(() => {
		document.body.dataset.autoTheme = auto ? 'true' : 'false';

		if (theme === 'dark') {
			document.body.classList.add('dark');
		} else {
			document.body.classList.remove('dark');
		}

		save(theme, auto);
	}, [theme, auto]);

	// ...
	// there‚Äôs more needed here, this is just for demonstration purposes
	// ...
}
```

This results in our first two steps:

1. The theme is tracked on the body element, like `<body class="dark" data-auto-theme="true">`
2. Our API (up next) is called every time the user preference changes.

### Prefers color scheme media query

Now that the basic plumbing is set up, we need to make sure that when theme switching is set to ‚Äúauto‚Äù mode that we start respecting the `prefers-color-scheme` media query using the [matchMedia API](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia):

```tsx title="ThemeSwitcher.tsx (partial)"
React.useEffect(() => {
	if (!auto) {
		// do nothing if not in auto mode.
		return;
	}

	// On change to auto-mode, set the theme based on the current media query preference
	const isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
	setTheme(isDark ? 'dark' : 'light');

	// Add an event listener any time the device requests a change to the color scheme
	function listener(event: MediaQueryListEvent) {
		setTheme(event.matches ? 'dark' : 'light');
	}
	window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', listener);

	// Return a cleanup function when unloading so we stop listening to the media change
	return () => {
		window.matchMedia('(prefers-color-scheme: dark)').removeEventListener('change', listener);
	};
}, [auto]);
```

That should be it for our theme switcher. Your implementation is really up to you, whether you‚Äôre using a dropdown, button, or some other UI is up to you. I‚Äôm going to gloss over all of that in favor of getting into the trickier parts of this article. If you‚Äôd like an example, you can always check out my [Solid-js implementation: `ThemeSwitcher.tsx`](https://github.com/paularmstrong/paularmstrong.dev/blob/8683b83f5fcebaa223b658bc1881d2db0be14524/src/components/ThemeSwitcher.tsx).

## Edge functions

As mentioned previously, we‚Äôre going to use [Netlify‚Äôs Edge Functions](https://docs.netlify.com/edge-functions/overview/) to handle the server-side portion of our requests. On the free plan, Netlify gives you three million edge function calls per month. That will be more than suitable for most small site‚Äôs like mine.

### API endpoint

First, let‚Äôs write our little cookie-setting API as a Netlify Edge Function. To start accepting calls to a URL, edit our Netlify config and add an `edge_functions` declaration. In my case, I put the pathname as `/api/theme/` and I'll name my function `netlify/edge-functions/set-theme.ts`:

```toml title="netlify.toml"
[[edge_functions]]
	path = "/api/theme/*"
	function = "set-theme"
```

Now that we have declared our endpoint, let‚Äôs actually write it to save the user‚Äôs theme choice as a server-side secure cookie:

```ts title="netlify/edge-functions/set-theme.ts"
import type { Context } from 'https://edge.netlify.com/';

// If you support more themes, this would be a great place to add them
const themes = ['light', 'dark'] as const;

export default async (req: Request, context: Context) => {
	const url = new URL(req.url);
	const params = url.searchParams;

	const theme = params.get('theme') as typeof themes[number];
	const auto = params.get('auto') === 'true';

	context.cookies.set({
		name: 'theme',
		value: params.toString(),
		path: '/',
		secure: true,
		httpOnly: true,
		sameSite: 'Strict',
		// Set a *REALLY* big expires value
		expires: new Date(Date.now() + 2_592_000_000),
	});

	return new Response(JSON.stringify({ error: false }), {
		status: 200,
		headers: {
			'content-type': 'application/json',
		},
	});
};
```

<Aside title="These use Deno!" type="tip">

One particular big caveat: Netlify edge functions use [Deno](https://deno.land/), not Node.js! So when you see an `import` statement that pulls from a URL, just know that this is _not_ a mistake.

</Aside>

Well, astute reader‚Ä¶ did you notice that I didn‚Äôt add any error handling here? Technically, someone could try to set any theme they want, even if it were invalid.

Let‚Äôs make sure we handle that both if a theme setting is not sent and if the theme is invalid:

```tsx title="netlify/edge-functions/set-theme.ts" {9-16,21-28}
import type { Context } from 'https://edge.netlify.com/';

const themes = ['light', 'dark'] as const;

export default async (req: Request, context: Context) => {
	const url = new URL(req.url);
	const params = url.searchParams;

	if (!params.has('theme')) {
		return new Response(JSON.stringify({ error: 'Missing theme parameter' }), {
			status: 400,
			headers: {
				'content-type': 'application/json',
			},
		});
	}

	const theme = params.get('theme') as typeof themes[number];
	const auto = params.get('auto') === 'true';

	if (!themes.includes(theme)) {
		return new Response(JSON.stringify({ error: `Invalid theme: ${theme}` }), {
			status: 400,
			headers: {
				'content-type': 'application/json',
			},
		});
	}

	context.cookies.set({
		name: 'theme',
		value: params.toString(),
		path: '/',
		secure: true,
		httpOnly: true,
		sameSite: 'Strict',
		expires: new Date(Date.now() + 2_592_000_000),
	});

	return new Response(JSON.stringify({ error: false }), {
		status: 200,
		headers: {
			'content-type': 'application/json',
		},
	});
};
```

### Rewriting static HTML responses

Next, again, we‚Äôll take a hint from our [inspiration article](https://www.learnwithjason.dev/blog/css-color-theme-switcher-no-flash) and rewrite part of our HTML responses for the static-generated multi-page site using Edge Functions. However, this is where we start deviating a lot more:

#### Accepting Client Hint headers

Since we want to be able to allow users to select an ‚Äúauto‚Äù select for the ‚Äúlight‚Äù or ‚Äúdark‚Äù mode, we need a way for the browser to tell us ahead of time what it actually wants on page load. In comes a new standard, [Client Hint Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Client_hints) and the [`prefers-color-scheme` client hint](https://developer.mozilla.org/en-US/docs/Web/HTTP/Client_hints#user_preference_media_features_client_hints).

To do this, in our Netlify `_headers` file, add the following so that all pages respond with the `accept-ch` header:

```text title="_headers"
/*
	accept-ch: sec-ch-prefers-color-scheme
```

<Aside type="danger" title="Client hints caveats">

It is important to note a really huge asterisk here, that I will likely have written [multiple times](#downsides) once this is all done[^clienthints]: client hints only work in [some browsers](https://caniuse.com/mdn-http_headers_sec-ch-prefers-color-scheme) and require at least one full network round-trip before the browser will start sending them to the server.

</Aside>

[^clienthints]: Client hints are currently only supported by Chromium-based browsers. This is a huge shame, but hopefully more pressure will be put on other browsers to get traction soon. See the section on [downsides](#downsides) for more information.

Once again, we‚Äôll use an edge function from Netlify for this. I‚Äôll walk through this one a bit to help explain better.

First, let‚Äôs start with a barebones edge function:

```ts title="netlify/edge-functions/theme.ts"
// Remember: this is Deno, not Node.js!
import type { Context } from 'https://edge.netlify.com/';
import { HTMLRewriter, Element } from 'https://ghuc.cc/worker-tools/html-rewriter/index.ts';

export default async (req: Request, context: Context) => {
	// Get the default response for this URL. This will grab the actual response as if we were not running this function
	const res = await context.next();

	// Check the content type. If we're not serving HTML, running the rest of this function is a waste of compute time and power
	const type = res.headers.get('content-type');
	if (!type?.startsWith('text/html')) {
		return;
	}
};
```

Next, we need to try to read the cookie and fall back on a default value if it‚Äôs not available. Using [nullish-coalescing](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing), we can make this fairly simple:

```ts
const rawCookie = context.cookies.get(COOKIE_NAME) ?? 'auto=true&theme=light';
const params = new URLSearchParams(rawCookie);
const isAuto = params.get('auto') === 'true';
const theme = params.get('theme') || 'light';
```

But the whole point of the `auto` setting on our theme switcher is that we want to read from the `prefers-color-scheme` client hint. So we‚Äôll modify this block just a smidge to read the header and if the cookie states that auto-mode is preferred, we‚Äôll use the header value if it‚Äôs available!

```ts {1,5}
const prefers = req.headers.get('sec-ch-prefers-color-scheme');
const rawCookie = context.cookies.get(COOKIE_NAME) ?? 'auto=true&theme=light';
const params = new URLSearchParams(rawCookie);
const isAuto = params.get('auto') === 'true';
const theme = isAuto && prefers ? prefers : params.get('theme') || 'light';
```

Lastly, just like in [the inspiration from ‚ÄúLearn with Jason‚Äù](https://www.learnwithjason.dev/blog/css-color-theme-switcher-no-flash#update-the-currently-selected-theme-in-the-dropdown), we‚Äôll use the HTMLRewriter and update the `className` and `data-auto-theme` attributes on our `<body>` element. All-together, our function looks like this:

```tsx showLineNumbers title="netlify/edge-functions/theme.ts" {17-25}
import type { Context } from 'https://edge.netlify.com/';
import { HTMLRewriter, Element } from 'https://ghuc.cc/worker-tools/html-rewriter/index.ts';

export default async (req: Request, context: Context) => {
	const res = await context.next();
	const type = res.headers.get('content-type');
	if (!type?.startsWith('text/html')) {
		return;
	}

	const prefers = req.headers.get('sec-ch-prefers-color-scheme');
	const rawCookie = context.cookies.get('theme') ?? 'auto=true&theme=light';
	const params = new URLSearchParams(rawCookie);
	const isAuto = params.get('auto') === 'true';
	const theme = isAuto && prefers ? prefers : params.get('theme') || 'light';

	return new HTMLRewriter()
		.on('body', {
			element(element: Element) {
				const original = element.getAttribute('class') || false;
				element.setAttribute('class', [original, theme].filter(Boolean).join(' '));
				element.setAttribute('data-auto-theme', isAuto ? 'true' : 'false');
			},
		})
		.transform(res);
};
```

Now we actually need to enable the edge function. In our `netlify.toml`, like we did before for the `set-theme` function[^htmlrewrite]:

```toml title="netlify.toml"
[[edge_functions]]
  path = "/*"
  function = "theme"
```

[^htmlrewrite]:
    Even though we‚Äôre ejecting early from our HTML rewriting edge function if the response does not have the `text/html` content type, there is still a limited number of edge function runs on the Netlify free plan. Yes, the limit is a big number, currently 3 million, but, let‚Äôs do our best not to get hit by any surprises.

    I‚Äôve split up my edge function into only running on known HTML page paths [`netlify.toml#L11-L35`](https://github.com/paularmstrong/paularmstrong.dev/blob/8683b83f5fcebaa223b658bc1881d2db0be14524/netlify.toml#L11-L35). I would have liked to have seen better path matching or a way to do an exclude-list along with a path glob, but alas, that feature does not exist yet.

## Downsides

First and foremost: Client Hints are still considered "experimental" and only available in Chromium-based browsers. For anyone not using one of those, the auto-theme selection won‚Äôt work and the [theme setting edge function](#edge-functions-as-an-api) will fall back on the last known `theme` value per the cookie.

Secondly, Client Hints are not provided by the browser to the server on _first_ load. While there are ongoing discussions about allows this to happen, there are technical challenges in making browsers first check which hints are being requested in order to send them. All this means that the even if you‚Äôre using a browser that supports Client Hints, your first page load to the site will always have a <acronym title="Flash of inAccurate coloR Themes">FART</acronym>.

We _could_ work around that by forcing a redirect/reload on first load, but that would require quite a bit of extra work that is frankly not worth the effort.

<Aside type="info" title="Alternative post titles">

I had some other stupid post titles in mind, but eventually settled on the safe, SEO-friendly one. But thought I‚Äôd share some here anyway:

- It‚Äôs like Gas-X, but for websites!
- Warn me with a _hint_ before you <acronym title="Flash of inAccurate coloR Themes">FART</acronym>

</Aside>
