---
title: 'Lessons learned: how I’d rebuild a web app like Twitter today'
pubDate: 11/26/2022, 9:00:00 AM GMT-0700
description:
toc: true
---

import Aside from '~/components/Aside.astro';

If I were to rebuild the Twitter web app today, or something like it, these are the things I would be pushing:

## [Solid-js](https://www.solidjs.com/) or another non-virtual DOM framework

Performance of Twitter web was absolutely critical when I was working on it. In fact, performance was so critical that we called with “Twitter Lite” (before the Android app was released) because its target market was those that needed to load and use Twitter as fast as possible.

While Twitter is a highly interactive application, for the most part, modifying the DOM only happens for virtual scrolling and navigation between URLs. There are a lot of little visual fluff additions, like the way the heart and retweet counts update in semi-real time. One of the difficult problems we had with those was ensuring only the portion of the UI that needed to update was updating.

With Solid-js’ [signals](https://www.solidjs.com/tutorial/introduction_signals) (now available in [Preact](https://preactjs.com/blog/introducing-signals/) as well) that only allow updating the minimal set of dependents, the above would not have been difficult.

## Remove [React Native for Web](https://necolas.github.io/react-native-web/)

We used React Native for Web (RNW). In fact, its creator was our tech lead for my first few years there until he left to join the React core team. While we got a lot of benefits out of RNW, we didn’t get any benefit out of the core selling point: cross-platform code. The native apps are highly optimized, do not, and will not use React Native. Without going into too much detail, I’ll just say it is not a battle to even try to fight.

Just as well, _web_ developers tended to have a lot of issues with RNW. Not directly, just that it wasn’t very ergonomic and took too much time to understand. While RNW (and React Native, for that matter) are moving to better direct web compatibility by accepting more web-native props like `aria-*=` (instead of `accessiblity*=`), it’s still a bit too much of a shift and frankly the library is falling behind.

For the most part now, all RNW is getting the team now is default styling, automatic LTR/RTL direction swapping, and some performance help under the hood. None of which aren’t easily handled otherwise.

## Add [Tailwind CSS](https://tailwindcss.com)

Without [React Native for Web](#remove-react-native-for-web), a CSS/styling solution would be necessary. After trying many of the options available, I feel confident in proposing Tailwind CSS for almost all new projects – especially Twitter.

We would be able to redefine and restrict the color, spacing, and sizing tokens down to exactly what the design team has defined. It is also possible to do most of the heavy-lifting on theming from within the Tailwind configuration.

Twitter currently does not create separate CSS assets that are cached in the CDN. All of the styles are delivered within the JS, causing extra network, evaluation, and runtime contention within the application. For our performance-first approach, it is imperative that we make gains here.

<Aside type="info" title="Not convinced?">

If you’re still not convinced on Tailwind, I suggest reading [Why we’re breaking up with CSS-in-JS](https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b) by Sam Magura, the second most active maintainer of the Emotion CSS-in-JS library.

</Aside>

**Bonus:** I would start using [client hints](/blog/2022/11/21/client-hint-headers-for-dark-mode-theme/) to determine what theme to serve to users on page load to avoid the current flash of super bright loading screen.

## Use [Vite](https://vitejs.dev/) or [TurboPack](https://turbo.build/pack)

Webpack is showing its age. Vite has shown it is a fast and solid alternative; TurboPack claims to be the successor of Webpack. Given that TurboPack isn’t widely available or tested for non-Next.js applications, I would likely end up choosing Vite, but still look for a path to swap for TurboPack and test as soon as possible.

The Webpack configuration at Twitter is a bit of an unruly beast. There were at most a handful of engineers (more likely one or two) that were confident in making changes to the configuration.

## Split into multiple applications with module federation

Twitter is a unique application – in that it could actually be a number of separate applications that have core shared modules. One thing that we struggled with for Twitter was moving fast on really small parts of the application, eg, “Settings”. Because everything in the application was interconnected and controlled by a single Node.js process, this made reviews, CI, and deploys slow. We could have, however, split things into multiple applications. For example:

- Tweet permalinks & Tweet timelines
- Home timeline
- Profiles
- Direct messages
- Settings
- New user onboarding

These applications then need a number of core shared modules, like the layout, user information, Tweet rendering components, etc.

All of this could be done and controlled with [Module Federation](https://blog.logrocket.com/building-micro-frontends-webpacks-module-federation/) in either [Webpack](https://webpack.js.org/concepts/module-federation/) or [Vite](https://github.com/originjs/vite-plugin-federation).

## Deno

Performance and server cost.

## Fastify vs Express

This may come as a surprise, but not a lot of performance gains would come through a slightly faster web server. This one would probably come down to personal/team preference.
